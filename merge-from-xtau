#!/usr/bin/env python

import os, sys, re, itertools, operator
from glob import glob
from collections import namedtuple, defaultdict
from rootpy.io import root_open
from rootpy.tree import Tree, TreeChain
import ROOT
import logging
from rootpy import asrootpy


from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument('-o', '--out', default='/coepp/cephfs/mel/lspiller/v8/hhskim/hhskim.root')
parser.add_argument('-i', '--infolder', default='/coepp/cephfs/mel/lspiller/hhsm_25.v8')
parser.add_argument('-cf', '--cutflow', default='h_mc_derivation')
parser.add_argument('--reset', action='store_true', default=False)
parser.add_argument('-db', '--deactivate-branches', default=['*_CP_*', 'tau*'])
args = parser.parse_args()
log = logging.getLogger(os.path.basename(__file__))


if os.path.exists(args.out):
    if args.reset:
        log.warning('Deleting %s' % args.out)
        os.remove(args.out)
    else:
        log.warning('Output file already exists!. Set --reset to overwrite. \n{0}'.format(args.out))
        sys.exit()

Sample = namedtuple("sample",
            [
                'fullpath',
                'files',
                'group',
                'chan',
                'subchan',
                'MCorData',
                'tag',
                'process',
                'derivation',
                'recotag',
                'hist',
            ]
        )

ls = lambda folder: glob( os.path.join(args.infolder, folder, '*.root*'))

folders = os.listdir(args.infolder)
samples = [ Sample( f, ls(f), *f.split('.') ) for f in folders ]
print samples

isvalid = lambda sample: \
    sample.group=='group' and \
    sample.chan=='phys-higgs' and \
    sample.subchan=='hhsm_25' and \
    sample.derivation=='D3' and \
    sample.hist=='v8_hist' and \
    sample.files != None

samples = filter( isvalid, samples )

process_dict = defaultdict(list)
for s in samples:
    procname = s.process if 'mc' in s.MCorData else s.MCorData + s.process
    procname = procname.replace('-', '_')
    process_dict[procname] += s.files

with root_open(args.out, 'UPDATE') as outfile:
    for procname, infiles in process_dict.items():
        log.info('{0} ...'.format(procname))
        files = map( root_open, infiles )

        hists = [ f.Get(args.cutflow) for f in files ]
        cutflow = reduce( operator.add, hists )
        cutflow.name = procname + '_daod'

        treenames = set([ t.GetName() for f in files for t in f.objects(cls=(ROOT.TTree,)) ])
        outfile.cd()

        outtrees = []
        for treename in treenames:
            intree = TreeChain(treename, infiles)
            for br in args.deactivate_branches:
                intree.SetBranchStatus(br, 0)

            outtree = intree.CloneTree(-1, "fast SortBasketsByEntry")
            outtree.OptimizeBaskets()
            outname = procname if treename == 'NOMINAL' else '{0}_{1}'.format(procname,treename.replace('up', '_up').replace('down', '_down').replace('__','_'))
            outtree.SetName( outname )

            outtrees.append( outtree )

        outfile.cd()
        cutflow.Write(cutflow.GetName(), ROOT.TObject.kOverwrite)
        for outtree in outtrees:
            outtree.Write(outtree.GetName(), ROOT.TObject.kOverwrite)
