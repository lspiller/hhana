#!/usr/bin/env python

import os, sys, re, itertools, operator
from glob import glob
from collections import namedtuple, defaultdict
from rootpy.io import root_open
from rootpy.tree import Tree
import ROOT
import logging
from rootpy import asrootpy


from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument('-o', '--out', default='/coepp/cephfs/mel/lspiller/v11/hhskim_z/hhskim.root')
parser.add_argument('-i', '--infolder', default='/coepp/cephfs/mel/lspiller/v11/unmerged/data/')
#parser.add_argument('-cf', '--cutflow', default='h_mc_derivation')
parser.add_argument('-cf', '--cutflow', default='h_metadata')
parser.add_argument('--reset', action='store_true', default=False)
parser.add_argument('--append', action='store_true', default=False)
parser.add_argument('-db', '--deactivate-branches', default=['*_CP_*', 'tau_*', 'ditau_CP_*',])# 'ditau_matched_*',])
parser.add_argument('-dr', '--dry-run', default=False, action='store_true')
args = parser.parse_args()
log = logging.getLogger(os.path.basename(__file__))


if os.path.exists(args.out):
    if args.reset:
        log.warning('Deleting %s' % args.out)
        os.remove(args.out)
    elif args.append:
        log.warning('Appending to %s' % args.out)
    else:
        log.warning('Output file already exists!. Set --reset to overwrite. \n{0}'.format(args.out))
        sys.exit()

Sample = namedtuple("sample",
            [
                'fullpath',
                'files',
                'group',
                'chan',
                'subchan',
                'MCorData',
                'tag',
                'process',
                'derivation',
                'recotag',
                'hist',
            ]
        )

#ls = lambda folder: glob( os.path.join(args.infolder, folder, '*.root*'))
ls = lambda folder: glob( os.path.join(args.infolder, folder, '*/*.root*') )

folders = os.listdir(args.infolder)
for f in folders:
    print f, len(f.split('.'))
samples = [ Sample( f, ls(f), *f.split('.') ) for f in folders ]

isvalid = lambda sample: \
    sample.group=='group' and \
    sample.chan=='phys-higgs' and \
    sample.subchan=='hhsm' and \
    sample.derivation=='D3' and \
    sample.hist=='v11_hist' and \
    sample.files != None
samples = filter( isvalid, samples )

#isdata = lambda sample: \
#    sample.group=='group' and \
#    sample.chan=='phys-higgs' and \
#    sample.subchan=='hhsm_25' and \
#    sample.derivation=='D3' and \
#    'data' in sample.MCorData and \
#    sample.hist=='v8_hist' and \
#    sample.files != None
#samples = filter( isdata, samples )

process_dict = defaultdict(list)
for s in samples:
    procname = s.process if 'mc15' in s.MCorData else s.MCorData
    procname = procname.replace('-', '_')
    process_dict[procname] += s.files


import pprint
pp = pprint.PrettyPrinter(depth=6)
pp.pprint(dict( process_dict ) )

if args.dry_run:
    sys.exit(0)

with root_open(args.out, 'UPDATE') as outfile:
    for procname, infiles in process_dict.items():
        log.info('{0} ...'.format(procname))
        files = map( root_open, infiles )


        print infiles
        treenames = set([ t.GetName() for f in files for t in f.objects(cls=(ROOT.TTree,)) ])
        outfile.cd()

        outtrees = []
        for treename in treenames:
            intree = ROOT.TChain(treename)
#            map( intree.Add, infiles )
            for infile in infiles:
                if root_open(infile).GetListOfKeys().Contains(treename):
                    intree.Add(infile)
                outfile.cd()

            for br in args.deactivate_branches:
                try:
                    intree.SetBranchStatus(br, 0)
                except:
                    pass
            log.debug("****************")
            log.debug("{}, {}, {}".format(intree, intree.GetTitle(), intree.GetName()))
            outtree = intree.CloneTree(-1, "fast SortBasketsByEntry")

            # Stupid hack because Cloning empty tchain returns a null pointer.
            if not outtree:
                log.warning("Tree has no entries: {0}".format(treename))
                dummy_tree = root_open(infiles[0])[treename]
                for br in args.deactivate_branches:
                    try:
                        dummy_tree.SetBranchStatus(br, 0)
                    except:
                        pass
                outtree = dummy_tree.CloneTree()

            log.debug("{}, {}, {}".format(outtree, outtree.GetTitle(), outtree.GetName()))

            outtree.OptimizeBaskets()
            outname = procname if treename == 'NOMINAL' else '{0}_{1}'.format(procname,treename.replace('up', '_up').replace('down', '_down').replace('__','_'))
            outtree.SetName( outname )

            outtrees.append( outtree )

            if not 'data' in procname:
                hists = [ f.Get(args.cutflow) for f in files ]
                cutflow = reduce( operator.add, hists )
                cutflow.name = outname + '_daod'

                outfile.cd()
                cutflow.Write(cutflow.GetName(), ROOT.TObject.kOverwrite)

        for outtree in outtrees:
            outtree.Write(outtree.GetName(), ROOT.TObject.kOverwrite)
